# <center>第二节 c语言编程基础框架framework</center>
  &emsp；IPO(i输入input information-p处理-o输出$\rightarrow$c语言基本框架)
### 1.基本数据类型
#### 1.1常量:
1. 数字常量
    * 整型
        * int定义的常量为 32bit$\rightarrow$%f
        * 可以用各种进制表示:10进制(Dec),2进制,8进制(Oct),16进制(Hex)等.
            1.计算机默认显示10进制
            2.可以指定进制:
            &emsp; 0x开头跟16进制的数,规则如下
            ![Snipaste_2021-09-23_16-16-25.png](https://i.loli.net/2021/09/23/9zkIoZ3rijENy65.png)
            &emsp; 0开头跟8进制的数
            3.8位和16位的意义是方便表示2进制,如16进制可以4个一组来转化2进制
    * 实数
        * double定义的常量为64bit;float32bit;如果太长,就加long;ll,来加长字符bit范围.
        1.特殊表示方法 (待完善)      
        2.科学计数法:用E 如2.8E-1 $\rightarrow$表示0.28
        3.实数(小数)和整数在计算机中的表示和保存方式不同,数值计算的精度和范围也不同,计算时的方法也不同.看着相同可能又本质区别.[^1]
        
[^1]:bit指一个二进制数位，byte=8bit。浮点数储存方式：1bit符号8bit整数23bit尾数，尾数和整数bit可以不断互补变化。

2. 非数字常量：
    * 字符串（本质是字符数组）
        1. 用双引号括起来的是字符串
        2. 字符串均以'\0'结束(系统会自动补上),所以**定义表示字符串的数组大小的一定要包括\0. **
        3. 详细输入方法在['scanf函数'笔记里](D:/yjw/vnote/程序设计基础/scanf函数.md)
    * 字符常量
        1. 字符必须要用＇＇引起来要定义的字符常量．
        2. ASCII码:一个字符根据这个 转化为数字.
        (插ascii码图片)
        &emsp; 注意ASCII码只有128位,所以只有8bit,故char只有8bit
        3. 转义字符:
        ![Snipaste_2021-09-23_16-43-41.png](https://i.loli.net/2021/09/23/pR9xtUjKy3czTwn.png)
 3. **整数常量：字符＆整数**
    * 字符也是通过ASCII来转化为整数,所以可以参与运算
    * 因为都用整数常量来储存,多以可以互相转化.
        * 比如:char='a',printf(%d) 就是97
        * int ch=97,printf(%c)   就是a
#### 1.2变量:
**<center>常量是固定的值,存储常量的存储单元就称之为变量.</center>**
* 变量的命名规则:
    1. 必须由字母或下划线开头,由字母,数字,下划线组成
    2. 系统保留的关键词,不能作为标识符.
*变量的命名规则:
    1. 骆峰命名法: 如stuScore首字母小写,其他每一个逻辑点都要用大写字母来标记
    2. 下划线法: 如stu_score
    3. pascal命名法: 每一个逻辑点都大写,用来命名c语言的函数.
* 变量的数据范围
![Snipaste_2021-09-23_17-02-04.png](https://i.loli.net/2021/09/23/8st9JiPub7WMAUh.png)
    1.浮点数表示的都是近似值,如1.1可能是0.999999999...,因为出现了一些循环
    2.浮点数使用标准数据格式（IEEE-754），float的有效数字大约相当于十进制的7位，表示范围大约为 -3.4*1038 ~ 3.4*1038，能表示的绝对值最小数约为10-44.85；double能表示的范围和精度更大。[^5]
    3.当字符过长时,最好用long long(int可加可不加)来定义变量，使变量达到64位，这样可以有效避免数据溢出。（比如除法运算经常会溢出导致结果不准确）
    4. 比较浮点数最好用相减,因为你不知道计算机用了什么方式储存那么多位的浮点数,所以容易出错.[^3]
* 变量类型转换:
    1.两个不同类型变量相互赋值,以左边的变量类型为准,可能造成数据精度的损失.
    2.变量赋值后才能访问.注意:不是所有编译器都会将空变量自动赋值为0,可能寄存器里原本没有清除掉的数据没有被覆盖掉,又被输出出来了.
    * 局部变量:在函数内的都是局部变量
    * 全局变量:在函数外的变量就是全局变量,注意,全局变量可以默认为0  
    * 注意:C96标准循环内不能定义变量,需要c99或c11
    3.常量变量类型限定:
    * const放在任何变量之前,说明该变量是只读的,不可更改[/关于变量循环中只读一次就不再改变的技巧](D:/yjw/vnote/程序设计基础/第二次上机教训.md#只读一次)
* 变量的自运算
    *  i++先参与运算再自加
    * ++i先自加再参与运算.如:b=i++,b=1,i=2; b=++I,b=2,i=2.
    * ++i可以作为左值进行赋值,i++不行.如++i=b,因为++i是已经完成运算的字符.

#### 1.3类型转换
![常见数据转换类型](D:/yjw/vnote/程序设计基础/图片/数据类型转换的几种情况.png)
*  隐式转换(自动转换)[^1]
    1. 字符与整型:可以用整数的地方就可以用符号,但是当整数位数太高时(超出ascii码128位限制)就会自动把更高位丢掉.
    2. 浮点数和整数转换一般会截取掉浮点数的小数部分(比如计算结果是小数,赋值给整数小数就没了),但实际情况有很多不同.[^2] [/实例](D:/yjw/vnote/程序设计基础/第二次上机教训.md#实例)[/更多浮点数转换零碎知识点](D:/yjw/vnote/程序设计基础/第二次上机教训.md#浮点数转换)
    3. 无符号整数:普通整数int和无符号整数unsigned混合使用,则普通函数也会变成无符号整数.
    4. 算数转换:运算表达式里的不同变量会自动转化成更高级的变量[^4]
  ![层级关系](D:/yjw/vnote/程序设计基础/图片/数据类型的层次关系.png)
    5. 赋值表达式使右边的结果自动转化成左边的类型.[/实例](D:/yjw/vnote/程序设计基础/第二次上机教训.md#实例)
* 强制类型转换:
在表达式或变量前强制加上`(新变量类型)`[/典例](D:/yjw/vnote/程序设计基础/第二次上机教训.md#典例1)


### 2.算数表达式&算术运算符
#### 算术表达式2.1
* 表达式的结果是有数据类型的，如果不同的数据类型，结果就和精度最高的那个保持一致。
    * e.g.2/3=0;2/3*1.0=0; 1.0\*2/3
* 不同运算符是有优先级的,所以最好用括号来保证计算顺序不出错.

:::alert-danger
取模运算的分配律:`(a*b)mod n与[(a mod n)*(b mod n)] mod n`
:::

#### 关系运算符与逻辑运算符
* 短路求值:`&&`(一方为0则全0)`||`(一方为1则全1)
```c
scanf("%c",&c);
if((c>='a')&&(c<='z'))//判断是否为小写字母
{...}
```
* 注意,逻辑运算符可以得出结果:结果为0或1,可以充分利用这一点.
    e.g.判断a,b,c,d,e有且仅有三个和数字顺序相同:
```c
if((a==1)+(b==2)+(c==3)+(d==4)+(e==5)==3)
VS
if((a==1)&&(b==2)&&(c==3)&&(d!=4)&&()&&()||(...))//非常冗杂的一段表达式.
```
* 更高级的表达式:
1. 条件?A:B    意思是满足条件结果是A,不满足条件,结果是右边的数.
```c
printf("%d\n", 3 < 5 ? 8 : 9);  
exe result==8;
```

2.语义转换:
   * ( a<=b) $\rightarrow$!(a>b)
   * (a!=b)$\rightarrow$!(a==b)
   * (x<=a)&&(x<=b)$\rightarrow$!(x>a)&&!(x>b)$\rightarrow$!((x>a)||(x>b))
3.关系运算符(判断大小)高于逻辑运算符(与或非),复杂条件多用括号/括号优先.
![](5319502160971.png)

* 宏定义
#define 代号 被代替的值,可以用代号来在程序代码中代替输入被替代的值,编译的时候会自动替换为需要用的值
 
```
 #define PI 3.1415926  
 #define -1 EOF
```
* 与const定义的区别:
    * const也可以定义"常数"但存在内存里,调用速度慢,会占用程序执行时间
    * define函数不会在执行时占用内存,因为在编译时define定义的量就会被自动替换为最终的量，只作为文本替换。
    * const int x=10;#define x 10;作用相同
    * const常量不宜用作数组定义的大小





 [^1]:这类转换很容易导致计算结果出错.
 [^2]:如果将浮点型强行以%d整数型输出的话,由于整数型和浮点型在内存中的储存方式不一样,所以读取的位置会出现很大的偏差,也就导致了输出的数特别离谱.
 
 [^3]:浮点数不能判断==,即使一摸一样的数也不行,因为最后几位很可能储存方式不同(浮点数的点的储存是浮动的,整数和尾数哪里多点可以灵活调整,小数点的位置位置根据需要而浮动。即小数点的位置不是固定的。)
 [^4]:例如整数型变量和浮点型变量一起运算,会将计算结果转化为浮点型.
 [^5]:注意,由于浮点数数据在内存中由符号域/小数域/指数这三部分组成,但浮点是浮动的.所以float有效数字一般只有6~7个,double则有15~16个,这就是为什么float感觉位数很多却表示不了多大的原因,后面很多位都会丢失.