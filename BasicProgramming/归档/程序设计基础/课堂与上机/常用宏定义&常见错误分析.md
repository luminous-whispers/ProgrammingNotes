# 常用宏定义&上机常见错误分析
## 常用宏定义
* ` #define FOR(x) for(int i=0;i<x;i++)`//注意,c89标准不能在for内定义变量.
>更方便的其实是#define CIRLE(n) while(n--)
* `#define MAX(x,y) (x>y?x:y)`
* `#define MIN(x,y) (x>y?x:y)`
* `#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))`
* `#define IF_EQ(a,b,c) (a==b?a:0)==c?1:0` 快速判断三者是否相等
* `n = sizeof(a) / sizeof(a[0])`<mark>int型</mark>统计数组有几个有效内容.
*`#define Equal_Zero fabs(delta)<eps`判断浮点型是否是零. (eps是个很小的数,叫精度,就是浮点型在计算机中储存的误差值. 小于这个值就可以认为该浮点型和0相等. 注意:浮点型不能直接和0比较)`#define eps 1e-6`



## 常见程序错误:
### 错误类型:
* 循环中,参考值(即用于判断而不直接参与赋值运算的值)是否归零. 检查,本次循环赋值的变量是否又参与到了下一次循环中,造成下一次循环错误
* 是否初始化局部变量
#### 字符串处理错误:
 * `gets()`以\n作为结束符号, 读到\n自动结束并将某位\n改成\0 (字符串结尾格式)(不读入\n!!!!)
 但这样带来一个问题, 就是gets之前缓冲区不 能有\n,否则会直接读入空行, 更严重的可能会导致循环里的gets直接死循环. 所以如果gets前输入时换行了的话, 就需要一个: `while(getchar()!= '\n')`来把缓冲区字符连同最后的\n全部吃掉.
 同理也适用于`scanf("%c",*char)`
 `while(gets()!=NULL)`来无限输入字符串直至文件末. 注意gets()不会把\n放入缓冲区内,所以上一个gets()行末的\n不会影响下一个gets, gets会读入此\n,然后将其转化为\0; 所以连续的gets之间不会相互影响.
 * 另外, 最好不要使用gets, 如果数组长度不够的话, 会溢出而不是截断, 导致程序崩溃. 推荐使用`fgets(str, n, stream);`stream可以指定为某个文件, 也可以指定为`stdin`就可以从标准输入中读取字符串了. 可以限制读入字符长度. 
> 若读取的字符数小于n，则会全部读取并且在最后一个字符后面添加'\0'，若读取的字符数等于n，则最多读取n-1个字符，第n个字符为'\0'。
> 在读取stdin时，我们输入回车代表输入结束，回车符会被fgets一起读进缓存。处理情况同上面的一样。
但是吧,fgets也有个毛病, 它会自动在字符串末尾多添加一个\n, 也是神坑! 形如: input:`'china' `,实际储存:` china\n\0`也就是说fgets也会吸收缓冲区的\n,>真蛋疼.< 
 
* 添加`fflush(stdin)`用来清空缓存区 /
### debug方法:
先确定各种数据的类型是否符合题意,然后确定前后文是否一致(如longlong配lld)
举极端的例子(超大数,特例数)
一组举完,举多组例子,看循环间是否相互影响
还不行就用调试和printf挨个检查中间变量, 调试只需光标选中然后点添加变量就能查看当前值, 注意, 形如a[i][j]也是可以查看的变量,不过会随着i,j变化. 
### 字符串比较:
* 中文比较:
中文占用两个字节.
一个字符占8位，一个字节，一个字节有8bit.
所以在char型数组中, 如果放入汉字字符串, 就会每两个地址(每两个角标)放一个汉字.
因此,使用strcmp()函数比较两个汉字字符串时就需要注意, char[]开大小时,要注意给字符串结尾留 \0位置. 
```c
int char[2]='中国’；//无法用strcmp函数
int char[3]='华夏’；//可以使用
```
* strcmp函数介绍： [^1]
`int strcmp(const char *s1, const char *s2);`
字符串大小的比较是以ASCII 码表上的顺序来决定，此顺序亦为字符的值。strcmp()首先将s1 第一个字符值减去s2 第一个字符值，若差值为0 则再继续比较下个字符，若差值不为0 则将差值返回。例如字符串"Ac"和"ba"比较则会返回字符"A"(65)和'b'(98)的差值(－33)。
若参数s1 和s2 字符串相同则返回0。s1 若大于s2 则返回大于0 的值。s1 若小于s2 则返回小于0 的值。

<mark>注意：strcmp() 以二进制的方式进行比较，不会考虑多字节或宽字节字符；如果考虑到本地化的需求，请使用 strcoll() 函数。</mark>
`strcmp("yuwei","yuwei"); `直接将一个字符串作为参数是被允许的.

### 绝对值函数:
```c
int abs(int i);                   // 处理int类型的取绝对值

double fabs(double i); //处理double类型的取绝对值

float fabsf(float i);           //处理float类型的取绝对值
```
浮点类型标识的有效数字及数值范围

    Float ：比特数为 32 ，有效数字为 6-7 ，数值范围为 -3.4E+38～3.4E+38
    Double ：比特数为 64 ，有效数字为 15-16 ，数值范围为 -1.7E-308～1.7E+308 
