# 第三次上机
## 基本数据处理
![](753940179397.png)
二进制转化为十进制，可以直接按每个位数分别算（1.2.4.8）
二进制转八进制，则三位一组分组表示。16进制4位一组。
* 二进制编码
1. 原码
    * 最高位代表符号位（0代表正）
    * 其余各位各表示绝对值
    * 缺点：
         0的表示不唯一
         符号不能参与运算，而且要底层设计额外判断符号的电路
2. 反码
    * 若为负数，则对其绝对值的原码取反
    * e.g. 
         +7: 00000111
          -7: 11111000
    * 缺点:
         0表示仍不唯一
3. 补码
    * 补数:
        *  时钟顺时针转9与逆时针转3等价,所以-3和9是关于12的补数,12称为负数和原数的模
        * 负数A的补数=模-A的绝对值.正数A的补码仍和原码相同
        * 在计算机中,由于位数限制,真正的运算是"取反加一".模和这个数占用的存储位数有关。
            e.g.-x $\rightarrow$ 16-x=15-x+1;
        ![](vx_images/1925757180099.png =290x)
        * 补码的范围更大:
            e.g.四位有符号：-8~7（而上面两种表示只能表示-7~7）
            因为多了一个-位，所以规定：如1000，0000表示-128，因为这一格空出来了。
            
*  位运算
    * 位运算预算符：
 ![](vx_images/708910186654.png =278x)
    1. 位运算只能用整型或字符型数据。
    2. 除~是一元运算符，其他均为二元。
    3. 位运算符不改变参与运算的变量的数值，只改变赋值变量
    * 按位与&
    ![](vx_images/3266914182408.png =208x)
    应用：清零（故意用0来&，则全部位数清零；1则会保存原来的数）
    ![](vx_images/2074922197892.png =292x)
    * 按位或|
    ![](vx_images/3405918200288.png =262x)
    * 按位异或^
    ![](vx_images/1115123195394.png =165x)
    同相斥，异相吸；0可以保留原来的数值，1不管原来的值是多少都翻转。
    * 取反~
    * 左移<<
        * 概念： 将二进制编码全部左移若干位，左边溢出的位数舍弃，右边补0
        
    * 右移：
        1011变为1101，因为有符号位。* 

浮点数判断大小要用相减

***
问题：
补码为什么包含符号位（阅读列表）补码为什么能直接参与运算
左移右移怎么表示
不同进制换算，小数换算。
整个后半部分都没有懂.......

***
a=a^b;
b=a^b;
a=a^b;

a=101010101
b=110111001

first: a=1 0 0 0 1 0 0 1 1
second: b=1 0 1 0 1 0 1 0 1
third: a=110111001

a=1 0
b=0 1

a=a^b= 00
b=a^b=10
a=a^b=01







