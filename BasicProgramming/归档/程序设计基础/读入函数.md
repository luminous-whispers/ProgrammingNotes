# scanf函数
![](D:/yjw/vnote/程序设计基础/图片/输入占位符.png)
还要加上
*变量数值输入(scanf):
1.scanf会忽略输入中的空格符/制表符/换行符(这个还需要研究),直接去读入有效数据,但是如果转换失败,读入就会停止.
2.format参数格式串中其他字符必须原样输入.format中不要用/n(原理待研究,输入的每行后面如果换行了,就相当于输入了一个\n,如果格式里没有\n就不会读入而忽略,如果格式里又\n,那就会把它读入造成错误.改成注释,ppt里有详细的）
Snipaste_2021-09-23_17-21-00.png
3.scanf函数返回成功赋值的数据项数,如果读到文末没有数据是返回EOF(-1)
应用:无限循环输入:

while(scanf("%d",&a)!=EOF)
while(~scanf("%d",&a))
注意用换行ctrl+z,+enter
用cmd来多组数据测试,可以模拟测试平台的测试机制.>out.txt
清理垃圾:while(getchar()!='\n');因为输入的符号b

***
　　博客摘录:
如果一个scanf的格式串以\n结尾，那么在读取完后还会阻塞等待，比如：

1 int a;
2 scanf("%d\n", &a);

这种情况，输入一个数字然后敲下回车后，程序还是阻塞着的。为什么呢？

处理格式串中的普通字符时，scanf函数采取的动作依赖于这个字符是否为空白字符（回车、tab、空格）。

　　如果是空白字符。当在格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配，包括0个。(可以在多个输入间隔无数空格的原因)

　　scanf("%d\n", &a)中的\n不表示等待换行符，而是读取并放弃连续的空白字符，你输入一个数之后，它是不会立即显示的，要等再接收到一个非空白字符（空格、制表符、回车）的输入scanf语句才结束。但请注意的是，最后输入的那个非（空格、制表符、回车）的东西是不会被这个scanf读进来的，而是留在输入流里。

　　格式串中的'\n'、‘tab’、‘空格’都属于空白字符，因此当遇到‘\n’时，程序会重复读空白字符直到遇到一个非空白字符为止”，由于输入缓冲已经没有字符可读了，因此将阻塞等待，直到读入了一个非空白字符为止。当程序阻塞的时候，我们直接按下回车，程序还是继续阻塞，只有当我们输入一个非空白字符并按下回车时程序才能继续向下执行。

　　如果格式串是scanf("%c",..)，那么%c会将空白字符读入并且成功返回.
　　scanf读取数值类型时用若用回车结束输入，那么会在缓冲区中留下'\n'，当下面紧接着一个读取字符类型的函数（比如scanf("%c",b),或者gets())
'\n'将会被读取。造成程序错误，这个问题必须引起注意。如果第一个scanf读取的是数值类型，例如scanf("%d", &num)，而紧接着的scanf也是读取的数值类型，则缓冲区的回车会被忽略，可以成功读取后面的数值。因为，缓冲区中的回车是属于字符，只有读取字符时才会把它当成一个有效的输入。

*  我程序不能自动进行下去的根本原因就是不知道scanf函数的本质.
* 有一个题目是,第二个输入包含"()",如果第一个scanf后不加\n,就会错误. 因为要强制要求输入一摸一样的符号"(",因为它准备接受的是字符型,所以会读入\n,但又发现读取的不是"(",所以就会认为是错误输入. 而scanf一旦读取到错误输入,就会立即停止该函数,直接返回-1.
要是必须要用的话,就在循环里getchar()把那个\n吃掉. 比如输入字符的上方必需要输入数字且换行,那么就可用这个把\n吃掉,确保下下面的程序不出错.

***

字符串名字就代表字符串的首地址，因此不需要加&。

字符串在存储上类似字符数组，所以它每一位的单个元素都是可以提取的，如s=“abcdefghij”，则s[1]=“b”，s[9]="j"，而字符串的零位正是它的长度，如s[0]=10。

在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。

char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

依据数组初始化规则，可以把上面的语句写成以下语句：

char greeting[] = "Hello";

***


在C语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：

    scanf()：通过格式控制符%s输入字符串。除了字符串，scanf() 还能输入其他类型的数据。
    gets()：直接输入字符串，并且只能输入字符串。
        需要注意的是,gets输入二维数组(如a[100][100])时,可以采用这样的结构: gets(a[n]);就代表第n行.

但是，scanf() 和 gets() 是有区别的：

    scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。
    gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说，gets() 用来读取一整行字符串。

`scanf("%c",&c1);//等价于 c1 = getchar();`

scanf函数是可以限制输入长度的，但scanf ("%s",a)这种写法没有使用它的限制功能，所以是不检查字符串长度；C/C++也是不检查数组越界的
#### 字符串处理错误:
 * `gets()`以\n作为结束符号, 读到\n自动结束并将某位\n改成\0 (字符串结尾格式)(不读入\n!!!!)
 但这样带来一个问题, 就是gets之前缓冲区不 能有\n,否则会直接读入空行, 更严重的可能会导致循环里的gets直接死循环. 所以如果gets前输入时换行了的话, 就需要一个: `while(getchar()!= '\n')`来把缓冲区字符连同最后的\n全部吃掉.
 同理也适用于`scanf("%c",*char)`
 `while(gets()!=NULL)`来无限输入字符串直至文件末. 注意gets()不会把\n放入缓冲区内,所以上一个gets()行末的\n不会影响下一个gets, gets会读入此\n,然后将其转化为\0; 所以连续的gets之间不会相互影响.
 * 另外, 最好不要使用gets, 如果数组长度不够的话, 会溢出而不是截断, 导致程序崩溃. 推荐使用`fgets(str, n, stream);`stream可以指定为某个文件, 也可以指定为`stdin`就可以从标准输入中读取字符串了. 可以限制读入字符长度. 
> 若读取的字符数小于n，则会全部读取并且在最后一个字符后面添加'\0'，若读取的字符数等于n，则最多读取n-1个字符，第n个字符为'\0'。
> 在读取stdin时，我们输入回车代表输入结束，回车符会被fgets一起读进缓存。处理情况同上面的一样。
但是吧,fgets也有个毛病, 它会自动在字符串末尾多添加一个\n, 也是神坑! 形如: input:`'china' `,实际储存:` china\n\0`也就是说fgets也会吸收缓冲区的\n,>真蛋疼.< 
 ![[Pasted image 20220422155305.png]]
 
* 添加`fflush(stdin)`用来清空缓存区 / 但有的编译器不会给过, oi赛制也不会给过, 因为验证答案不是验证的缓冲区而是文件.

***

格式读入： sscanf函数
```c
char weekday[20], month[20], dtm[100];

   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );

   printf("%s %d, %d = %s\n", month, day, year, weekday );
```
```c
output:  March 25, 1989 = Saturday
```
* 常见错误:
`sscanf(str1, "%s-%d",str2,&a);`原意图是借助-符号来取出str1字符串中的一个数字, 但是当函数读到%s, 会去str1中找一个字符串返回, 那么就会把str1全部读入str2中,导致a并没有任何值. 


***

输入时需要注意的一些小细节:

* 输入字符前的预处理
当下面要用读入字符型时, 要留意之前是否有空白字符. 不要以为前面仅有一个换行就真的只有一个换行, 要是助教故意给你加几个隐藏的字符, 那光用一个getcha()就不顶用了.
最好用结构: `while(getchar()!='\n')`
    * 当然, 如果真的只有一个\n的话, 也不用getchar那么麻烦.....
    用: `scanf("%d%d ",&n,&l); `解决吧, 注意格式串后面有个空格.

* 留意下scanf和gets读入字符串时返回值的区别:
`while(scanf("%s",str)!=EOF)`versus  `while(gets(str)=NULL)`

* 注意scanf和printf入栈问题, 不要作死在同一个printf或scanf函数内反复变换值（具体请见marklist）
```c
a=1;
printf("%d %d %d",a,a++,++a);
```
*results: 3 2 3*
surprise! 这不仅是从右向左输出的问题, 我们先明确一点, 传入pirntf函数时是从右向左压栈的,再从栈顶逐个输出.
只有a++会拷贝副本,++i直接在原数据操作. a++的真实内涵不是先运算再++, 而是编译器会对a拷贝出一份副本,再操作真值加一. 这样的好处明显是避免编译器底层歧义, 但通俗的解释(先操作再运算)容易让人理解错误.
传入printf函数里的仅仅是个指针而已并不是真的值, 所以传入的仅仅是a的指针而不是a的值, 所以a的值仍是会不断变化的, 以最终的值为准. 所以以上例子种:  (我们假设第一次a++时拷贝值存入了变量a1)

|  栈  |  值  |
| --- | --- |
| \*a | 3   |
| a1  | 2   |
| \*a | 3   |