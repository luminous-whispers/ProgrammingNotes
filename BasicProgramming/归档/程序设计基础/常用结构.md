# 常用结构&常用技巧
## <div id="无限循环结构">无限循环结构</div>
### 无限循环基本结构
1. 无法主动结束的无限循环`for(;;)`or `while(1)`
2. 可以主动结束的无限循环[^2]
* `while(scanf("%d"，&n)！=EOF)`
    * 解释:
        1. 当程序读到行尾的时候,会返回EOF
        2. 没读到行尾的时候不会返回EOF,程序无限循环下去
        3. 必须手动结束循环.
        4. 地址类型错误返回值要用: NULL
* `while(~scanf("%d"，&n)）`
    * 解释:
        1. ~代表按位取反
        2. scanf函数返回值是接受值的类型正确的个数[^3],没有输入值就是返回-1;
        3. -1按位取反的结果是0,while(0)结束循环.[^4]
        4. 但是,scanf函数并不知道你最后一次不输入了,它仍在等待你的输入,所以你需要手动输入终止命令.(上同)[^1]
>! :代表逻辑取反，即：把非0的数值变为0，0变为1; 
>~ :表示按位取反，即在数值的二进制表示方式上,将0变为1，将1变为0；
如`if(!x)==if(x==0)`
还有一个等价的写法: while( ~scanf("%d", &n))
  这个写法的合理性在于, 当返回值为EOF时, EOF=-1, -1的就是1的原码, 即1的反码加1, 也就是1111...11110+1, 取反就是0, 所以会退出

:::alert-danger
输入-1或EOF可能会导致程序直接停止,你后面的语句可能不会再被执行.
:::

*  `while(n--)`
    * 循环n次,且只用定义一个变量即可.
    * 解释:while循环到0就会结束循环.

### 无限循环的终止
if(!(i%j)) //if(i%j==0)
```c
//e.g. 将整数a转化为二进制数。
while(a){
	bit=a&1;//bit为1，则当前a二进制下最低位为1，反之亦然
	a/=2;
}
```
```c
while((ch=getchar())!=EOF) //字符型读到文件末尾返回的是EOF
while(gets(a)!=NULL)//gets读到文件末尾返回的空指针.
```

## 位运算奇技淫巧
不推荐使用: 使程序变得难读和难以理解(当然加注释另说)

* 基础位运算理解:  

|   运算   |     理解      |   运算   |   理解   |                     应用                     |
| -------- | ------------- | ------- | -------- | ------------------------------------------- |
| `0&a=0`  | 0&bit数->归零 | `1&a=a` | 保留本身 | (1<<n)&某数->取出第n位的bit值                 |
| `1^a=!a` | 1^bit->取反   | `0^a=a` | 保留本身 | 找两数二进制不同,取出仅出现一次的数(大部分为2次) |
| `1|a=1`  | 1`|`bit->归1  | `0|a=a` | 保留本身 | \|有1短路功能.                                |
* 交换两变量内容:
> 特点是不需要引入中间变量.
>当然其实常规也能实现,但效率低
```c
void swap(int a, int b) 
{
    a=a+b;
    b=a-b;
    a=a-b;
}//这样写是完全错误的, 思考一下为什么?
```
位运算:
```c
void swap(int &a, int &b) {
  a ^= b;//a=a^b
  b ^= a;//b=b^b^a, x^x=0, 0^x=x;
  a ^= b;//a=a^b^a(现在储存在b中)=a^a^b=b;
}//a^=b^=a^=b;
```
* 判断奇偶：
>解释： 只需根据最后一位来判断即可， 0 就是偶数，为 1 就是奇数。
```c
if(0 == (a & 1)) {//a末位以上都被0&没了,所以a相当于被清空到只剩一位
 //偶数
}
```
* 取相反数
```c
int reversal(int a) 
{
  return ~a + 1;//补码等与原码的反码加1;
}
```
* 取绝对值
```c
int abs(int a) {
  int i = a >> 31;//注意有的编译器好像不让一次性右移这么多位, 好像可以分步右移.
  return i == 0 ? a : (~a + 1);
}
or
int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}
```
* 统计某数二进制表达中1的个数
```c
count = 0  
while(a){  
  a = a & (a - 1);  //每次消除掉最低位的1;
  count++;  
} 
```
>具体应用:
    1. 判断n是否是2的幂次(因为那样的话只有一个1)
    2. 判断数a转化为b需要改变多少bit位? (用a^b, 然后判断这个数1的个数)
## 比较与判断浮点数
* 判断两浮点数是否相等:
```c
#define epsilon 1e-6
double a,b;
if((a-b)<epsilon)
printf("a==b");
```
* 判断浮点数是否是0
```c
#define epsilon 1e-6
double a=0;
if((a>=-epsilon)&&(a<=epsilon))
prinf("a==0");
```
## 四舍五入
* `printf("%.4f",a);`这样强制输出位数， 该数会被强制四舍五入的。但由于float储存误差,这样是有错误几率的, 所以我们必须要人工处理
* 但printf的四舍五入不能参与到后续运算中.
```c
//假设float a=1.23456, 而你想只保留三位小数,也就是希望得到1.235
a=(int)(1000.0*a+0.5)/1000.0;
//1000.0是想不想让a直接变成整型;(int)变换的是分子,不放心就加括号.
```
!!
> 注意这种方法仍不保证百分之百正确,最保险的方法是把需要精确的那一位取出来和5比较.
> 至于为什么要强行+0.5而不是0.005, 是因为较小的小浮点数仍然会出现奇怪的bug.
## 哈希表储存信息
至于众数怎么算，可以开一个 score[101] 数组，score[i] 代表分数 i出现的次数。

上面的 score[101]叫做哈希表，可以通过数组的下标，直接索引到该分数的出现次数。

哈希表在写程序中非常好用，最基础的哈希表就是将数组下标当作索引。

>1. 例如多组数据输入一个年级所有同学的生日，想要统计在每天过生日的同学有几名，可以开一个数组birthday[1235]，其中birthday[1016]储存在十月十六日过生日的同学的人数，birthday[131]储存在一月三十一过生日的同学的人数，这是一种哈希表。
>2. 如果想要统计学号为18375030到18375168之间的同学的成绩，可以开一个数组a[200]，其中a[76]便储存着学号为18375076的同学的成绩。便是建立了一个数组下标 = 学号 - 18375000的映射，提高程序性能，是一种优化过的哈希表。

将生日 / 学号 / 字符的ascii码等我们需要的信息，通过一定函数（如f(x)=x−18375000
），映射到数组下标而形成的数组，便是哈希表。我们通过下标读取数组元素，就可以得到想要读取的信息，十分便捷，希望给大家留下些许印象。


[^1]:手动结束的方法:
windows下可通过按“Ctrl +Z”、linux下可通过“Ctrl + D”来来达到“输入”文件结束符的效果，结束循环。
[^4]:更多按位取反规则:
1.所有正整数的按位取反是其本身+1的负数
2.所有负整数的按位取反是其本身+1的绝对值
3.零的按位取反是 -1（0在数学界既不是正数也不是负数）
[^2]:注意这两种方法在输入字母(字符)的时候会变成死循环,但scanf("%d%d",&a,&b)==2这种强行判断输入成功的方法不会死循环.
[^3]:输入成功2个,就返回2;输入成功0个就返回0;出现错误就会返回EOF.










