# **计算最大公约数与最小公倍数**
## 两个数: 
假设为x,y. 设它们的最大公约数为a,最小公倍数为b;               l
    * 要点: x\*y=a\*b
        理解为 $\frac{x*y}{a}=b$ x\*y除以某个数可以得到最小公倍数, 这个数是一个公约数就可以消除x\*y中重复的质因数. 我们知道最大公约数就是x,y中所有重复质因数的乘积, 所以显然x*\y/a就是最小公倍数.
    * 下面求最大公约数, 采用辗转相除法(互减法)
        * 原理: 显然: x=m\*a ; y=n\*a ; x-y=(m-n)\*a.  所以我们不断地用较大地数减去较小的数,直到减到最小, 则最小值显然就是a; (推荐画图理解)
        * c代码实现:
 ```c
//注意保证a>b
 int gcd(int a,int b){
	return (b==0?b:gcd(b:a%b));//这里是一个递归.
	//a%b其实就是用a减b, 如果仍大于b, 就接着再不断减b, 直至a-n\*b<b为止的意思. 
 }
 ```
    * 最小公倍数的代码就很显然了:
```c 
int lcm(int a,int b)//a>b{
	return (a*b/gcd(a,b)) ; 
}
 ```
 
 ***
		
## 多个数:
### 方法
* 如法炮制 最大公约数: 取(a,b,c,d)
	1. 取几个数中最小的数, 假设为a;
	2. 其余每个数分别与a相减, 得出的数组最大公约数仍未变;
	3. 重复1,2步骤; 
	4. 出现0后,排除0,对其余数继续进行该步骤;
	5. 直至只剩下一个元素非0, 即为最大公约数.
###  代码:
```c
#define MIN(x,y) (x<y?x:y)//搞个最小值算法的宏定义,方便后面理解.
int i=1,q=1,a[10000],zero=0;//zero是用来统计数组里出现了几个0
int min,sign;//这个sign用来标记最后哪个不是0
int main()  
{
while(1)
{
	scanf("%d",&a[i]);
	i++;//记录输入了几个值来求最大公约数
} 
while(1)
{   zero=0;
	min=100000;//比较最小值需要一个比较大的值;千万别把min赋值为0,否则怎么比较min都是0,因为0小于任何正数.
	for(q=1;q<=i;q++)
	{
		if(a[q]!=0&&a[q]<min) min=a[q];
		if(a[q]==0) zero++;
		if(a[q]!=0) sign=q;
	}
	for(q=1;q<=i;q++)
	{  
		if(a[q]>min)
		a[a]=a[q]-min;
	}
	if(zero==i-1) {printf("%d",a[sign]); break;}
}
	return 0;
}
```
* 多个数最小公倍数
	* 先取最前面两个元素，按上述方法求出最大公约数，然后再把这个数和下一个元素求最小公倍数，一直求到结尾位置。
	* 代码: 略

































