### 脚本式编程:
意思就是解释器会按照你写的脚本, 一步一步的执行程序, 直到程序执行完.

## 格式
### python标识符
1. 由字母, 数字, 下划线组组成, 但不能以数字开头
2. 区分大小写
3. 以下划线开头具有特殊意义
    单下划线开头, 如_foo, 不能直接访问类属性
    双下划线开头, 如__foo, 代表类的私有成员
    双下划线开头并结尾, 如__foo__代表类的构造函数
4. python只保留一些小写字母关键字

* python行末不必加 ; 
    但如果想一行容纳多个语句, 可以加 ; 实现
    python一般以新行作为语句结束符, 但是我们可以使用斜杠 | 分为多行显示; 语句中有括号也是可以直接换行的{}
* !! python的最大特色是, 不以{}来控制类等, 而是用缩进来写模块
    缩进的空白数量是可变的, 但是所有代码块语句必须包含相同的缩进空白数量.
    比如错误:IndentationError: unexpected indent 就很可能是tab和空格没对齐的问题. 所以不同缩进层次千万不能混用.
* python的双引号和单引号没有直接区别, 都用来定义字符串
    但是如果字符串中包含单引号,就可以用双引号定义
    python三引号('''或""")特点是可以由 **多行** 组成
        三引号还可以用于多行注释

### python注释
python注释以#开头, 注释可以单独一行, 也可以在语句或表达式行末.

### python空行
函数之间或类的方法之间用空行分隔, 表示一段新代码的开始. 类和函数入口之间也用一行空行分隔, 以突出函数入口的开始.

### pythhon代码组
首行以关键字开始, 以冒号 : 结束. 改行之后的一行或多行代码构成代码组, 将首行及后面的代码组称为一个子句(clause)
如: 
```python
    if expression :
        suite
    elif expression :
        suite
    else :
        suite
```

## 变量类型
**python中的变量赋值不需要类型声明!!**
变量使用前都必须赋值, 赋值后该变量才会被创建
* 同时为多个变量赋值:
    `a = b = c =1` 此时a,b,c会指向同一内存地址
* python五种标准的数据类型
    1. Numbers 数字 (不可变)
    2. String 字符串 (不可变)
    3. List 列表
    4. Tuple 元组 (不可变)
    5. Dictionary 字典
### 不变型
例:
```python
>>> x = 1
>>> y = 1
>>> z = 1
# 此时x,y,z其实都是指向**同一个**值为1的内存地址. 
>>> d = 2
>>> d = x
# 注意并不修改原本值为1的内存， 仅仅将d执行与x指向的内存绑定。
# 此时内存中值为1的内存地址引用计数-1， 当引用计数为0时， 内存地址才被收回
```
* 变量的删除
del 可以删除变量的定义, python3.x中del并不是函数

整形目前仅支持 ( -1, 100), 常驻内存的整数范围时-5~99
* 优点: 减少重复空间的占用
* 缺点: 如果某个整型尚且没有内存,那么必须重新开辟一块内存, 把新地址与变量名绑定. 而不是仅仅修改内存块的值, 那么执行效率必然会降低.
* 257是临界点, 数值超过以上的变量重复命名就会改变id地址

### python数字
- int 整型
    Py3.x去除了long类型, 现在只有一种整形-int, 表示长整型
- float 浮点型
    浮点型也可以使用科学计数法表示 <br>
    `type( 2.5 )
    <class 'float'>`
-  complex 复数
    形式: x + yj
#### 整数溢出
* python无需担心整数溢出问题,它支持**无限精度**的整数
* 但是浮点数只能精确到15位小数( 16位不准确, 从16位开始截断 )
#### 数字系统
| 数字系统 | 前缀 |
| ------ | ---- |
| 二进制 | '0b'或'0B' |
| 八进制 Octal | '0o'或'0O' |
| 十六进制 Hexadecimal | '0x'或'0X' |

#### 数字运算
| 运算符 | 功能 |
| ---- | ----- |
| % | 取余 |
| ** | 幂 |
| // | 取整数 |

* python中公式一旦出现小数点, 结果就是浮点数
* 进制转换：
```python
>>> 0b110 #输出十进制数, 注意无空格
>>> bin( 14 ) #bin（）函数能够将十进制数转化为二进制
>>>　chr( 13 ) #chr函数将数字按ASCII码转化为符号。
```
* 数据类型转换函数汇总:
| 函数 | 作用 |
| --- | ---- |
| int( x ) | 将x转为整型, x为数字或字符串型的数字, 复数不可以 |
| float( x ) | 转为浮点型, 复数不可以 |
| comoplex( x, y ) | x,y为整数,浮点数,布尔型; 当只有x时, x可以为字符串型 |
| str( x ) | 转化为字符串 | 
| bin( x ) | 转化为二进制, x为非负整数 |
| oct( x ) | x转换为八进制值, x为非负整数 |
| hex( x ) | 转化为十六进制, x为非负整数 |
| chr( x ) | 转化为ACSII字符, x为十进制数 |
| ord( x ) | 转化为十进制数, x为ACSII码字符 |
| eval( str ) | 用来计算在字符串中的有效python表达式并返回对象 |
| tuple( s ) | 将序列s转化为一个元组 |
| list( s ) | 转换为可变集合 |
| set( s ) | 转化为可变集合　｜
｜　frozenset( s ) |　转换为不可变集合　｜


#### 逻辑运算符:
* 和c不同之处：
    ~ 按位反转运算符
        作用类似于: ～ｘ <=> -x-1 (因为原码是取反加1)
* 优先级:
    **逻辑运算符 < 比较运算符 < 算术运算符/位运算符**

* 成员运算符
    in
    not in
```python
# e.g.
a = 10
list = [ 1, 2 ]
if( a in list )
    print( "yes" )
else 
    print( "no" )
# 结果： no

```

* 身份运算符
    is 判断两个标识符是不是引用自同一个对象
    is not
    * is 与 == 的区别:
    is用于判断两个变量引用对象是否为同一个(同一块内存空间), ==用于判断引用变量的值是否相等.
    所以is 实际上等价于 id(a) == id(b), 用is需要对python内存管理有一定理解
        坑: 注意字符串, 空格有时候会导致字符串id不一致, 是因为字符驻留机制的bug导致的
* python的巨坑:
    False == 0
    指定非0和非空(null)值为true, 0或者null为false

##### python中None
None : class'NoneType', 它的数据类型和任意变量都不同
* python中的判空操作:
    if a is None 不推荐, 当a是不同类型时会出错
    if not a 推荐

* None用法:
    判断函数无返回值

#### 赋值运算符:
| 运算符 | 名称 | 规则 |
| --- | ---- | ----- |
| += | 加法赋值 | x+=y <=> num=x+y |
| -= | 减法赋值 | x-=y <=> num=x-y |
| \*= | ... |  x \*=y <=> num=x*y |
| /= | ... | x/=y <=> num=x/y |
| **= | 幂运算赋值 | x\*\*=y <=> num=x\*\*y |
| %= | ... | x%y <=> num=x%y |
| //= | ... | x//=y <=> num=x//y |
| <<= | 右移位赋值 | bin1<<=m <=> bin=bin1<<m | 
| &= | 位于赋值 | bin1&=bin2 <=> bin=bin1&bin2 |
| \|= | 位或赋值 | bin1\|=bin2 <=> bin=bin1\|bin2 |
 
> 同理有 ^=,>>=
> 其实就是c中的自增嘛, x+=y <=> x=x+y

### python字符
0. 字符串不能改变
    不能重新赋值
    , 用完就del掉
1. 字符串索引值:
   * 从头开始数,则从0开始, 0,1,2...
   * 从末尾开始数, 则从-1开始, -1,-2,-3... 

```python
>>>str = 'python'
>>>print( str[ 0 ] ) #output = p
>>>print( str[ 0 : 4 ] ) #output = pyth 正数前四个字符
>>>print( str[ -1 ] ) #output = n 倒数第一个
>>>print( str[ 0 : -1 ] ) #output = pytho 第一个到倒数第一个，但不包括倒数第一个(尾下标)
>>>print( str[ 0 : ] ) #output = ython 输出所有
>>>print( str + '哈哈哈哈' ) #output = python哈哈哈哈 
>>>print( str *3 ) #output = pythonpythonpython 注意*和3间没有空格
>>>print( str[ 0 : 5 : 2 ] ) #第三个参数是步长
```

2. 字符串格式化
    * 三种方式:
```python
a = "你的名字叫 %s ,今年 %s 岁" % ( '李四' , 18 )

b = "你的名字叫 %(name)s ,今年%(age)s岁 % { 'name':'李四','age':28 } 
#给标签

c = "你的名字叫{} ,今年 {} 岁".format( '李四' , 38 )
```

### python元组
* 写在小括号里, 元素间用,隔开
> 功能和MMA的列表类似
>　元组中元素索引值和字符串类似
* 和列表的区别:
    http://c.biancheng.net/view/4363.html
    总结起来:
    1. 列表可变, 元组不可变
    2. 由于性质一导致的, 元组占用储存空间少, 并且访问更加快速.
    3. 列表以[]区分, 元组以()区分
* 特殊元组:
    1. 空元组 `tup1 = ()`
    2. 一个元素元组 `tup2 = (1,)`
* **元组一旦初始化就不能修改, 是不可变数据类型**
    * 内置id()函数返回对象的内存地址
    * python当不可变数据类型对应变量值发生了改变, 那么它对应的内存地址也会改变.( 重开一块地址, 而不是去改变原地址内的值. 后面的变量会覆盖前面的变量)
    * 对于元组来说, 不可变意味着如果想修改其中任意一个值, 那么元组所有其他元素都会初始化. 也就是说不能单个元素更新, 只能整体赋值新的元组
#### 元组内置函数
1. len( tuple ) 计算元组元素个数
2. max( tuple ) 返回元组中元素最大值
3. min( tuple ) 返回元组中元素最小值
4. tuple( iterable ) 将可迭代系列转换为元组
5. del tup 直接删除整个元组(并不是修改)

### python字典
列表是有序的对象集合, 字典是无序的对象集合. 
<br>
    列表通过偏移存取, 而字典中的元素通过"键"来存取
    字典以{}标识, 由索引"键"和它对应的value组成的
e.g.

```python
#!/usr/bin/python3
# -*- coding: UTF-8 -*-

dict = {}
dict[ 'one' ] = "This is one" #添加或更改字典字典值
dict[ 2 ] = "This is two"

tinydict = { 'name':'runoob' , 'code':6734 , 'dept':'sales' }

print dict[ 'one' ]
print dict[ 2 ] #输出键为2的值
print tinydict #输出完整字典
print tinydict.keys() #输出所有键
print tinydict.values() #输出所有值
print tinydict.items() #输出所有 “键：值“ 组合
```

#### 删除字典元素
```python
del dict[ 'key' ] # 删除键'key'
dict.clear() #清空字典 (注意序列式元素的操作, 很多都是: 变量名.操作 这样的命名规则) 
del dict 删除字典, 删除之后这个变量名也不复存在了.
```

### python集合
用大括号或set()创建, 但是注意{}不能初始化空集合, 因为这是字典的操作
* 集合和字典都有自动去重功能
* 集合之间的运算有: 
    1. a-b 包含在a但不在b中的元素
    2. a | b a并b
    3. a & b a交b(a,b都包含)
    4. a ^ b 不同时包含于a,b的元素
* 集合同样支持推导式, for in if
* 基本操作:
    1. set.add( x ) 将x添加到集合set中
    2. set.update( x ) 同样, 但是x可以式列表/元组/字典等, 并且x可以有多个
    `set.update( {1,3} ); set.update( [1, 4], [5, 6] )`
    3. set.remove( x ) 移除元素/ 但如果不存在就会发生错误
    4. set.discard( x ) 移除元素, 但不存在也不会发生错误
    5. set.pop() 随机弹出集合中的一个元素, 删除并返回这个元素
    6. set.clear() 清空集合
* 集合不会以特定顺序存储元素. (别的数据类型会按插入顺序)